# 索引

1. [索引结构](https://github.com/zongzhenh/Blog/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/(4)%E7%B4%A2%E5%BC%95.md#%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84)
2. [执行计划](https://github.com/zongzhenh/Blog/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/(4)%E7%B4%A2%E5%BC%95.md#%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92)
3. [最佳实践](https://github.com/zongzhenh/Blog/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/(4)%E7%B4%A2%E5%BC%95.md#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5)

## 索引结构

索引类型大体上分为两种：聚簇索引（或者叫主键索引）和二级索引，二级索引又分为单列二级索引和联合二级索引。
InnoDB 常用的索引数据结构是 BTREE，树的高度表示所需的 IO 次数（树高一般 2-3 层）

### 聚簇索引

![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-2.png)

结构说明：

- 每一个大的矩形代表 BTREE 的一个节点，其中像「页号 43」这种叫内节点，41 和 42 叫叶子结点
- 节点内部一般有多个记录，记录之间组成一个有序的单向链表（这也是为什么 `ORDER BY` 的字段如果加了索引会更快的原因之一，因为本来就是有序的，无需再排序）
- 同一层的多个节点之间组成一个有序的双向链表（这也是为什么 `ORDER BY` 的字段如果加了索引会更快的原因之二，因为本来就是有序的，无需再排序）
- 上层节点和下层节点之间符合查找二叉树左小右大的查找规律

颜色说明：

- 绿色代表页号，也就是 BTREE 节点的编号
- 粉色代表记录类型
  - 0：代表叶子结点的记录
  - 1：代表内节点的记录
  - 2：代表最小记录（作为边界）
  - 3：代表最大记录（作为边界） 
- 浅蓝色代表主键
- 黄色代表真实的数据列

### 二级索引

#### 单列二级索引

![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-3.png)

二级索引的结构和聚簇索引基本相同，深蓝色代表的是加了二级索引的列

**⭐️ 和聚簇索引不同的是，二级索引的叶子结点并不保存所有真实的数据列，保存的是二级索引列和主键，也就是说如果需要其他列的数据，
就需要根据主键进行回表（回表是指，根据主键继续到聚簇索引查找真实的数据列）。而且是有一条记录，就回表一次，因此回表会导致性能下降**

江湖上流传的跟回表有关的优化建议：

- 尽量使用到覆盖索引。因为如果需要查询的列刚好是加了二级索引的列或者是主键，那就避免了回表
- 尽量不要在基数少的列上加二级索引。因为这样查询出来的记录会很多，如果所需的字段不止二级索引列本身的话，回表的次数也会很多

#### 联合二级索引

![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-4.png)

紫红色代表的另外一个加了索引的列，它和深蓝色共同组成一个联合索引。BTREE 查找的过程中，如果发现第一个索引列相同，就根据第二个进行排序。联合索引同样需要回表

## 执行计划

执行计划的作用：

- 分析索引使用情况，提供优化依据
- 连接查询时，显示驱动表是哪个，被驱动表是哪个（驱动表在前面，被驱动表在后面），从而可以分析被驱动表的连接列上有没有用到索引

```SQL
mysql> explain select * from employees where emp_no = 10001;
+----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table     | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | employees | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```

```SQL
mysql> explain select * from employees where first_name = "Georgi";
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | employees | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 299379 |    10.00 | Using where |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

报告说明：

一般主要看 `type`、`possible_keys`、`key`、`rows` 这几个字段

- `possible_keys`：表示有哪些候选的索引
- `key`：表示最终用了哪个索引
- `type`：索引的效果指标，`const` > `ref` > `range` > `index` ~= `ALL`
  - `const`：聚簇索引或者二级索引 + `where` 等值匹配 + 单表查询 + 查询结果只有单行匹配
  - `ref`：二级索引 + `where` 等值匹配 + 查询结果有多行匹配
  - `range`：二级索引 + `where` 范围匹配
  - `index`：扫描聚簇索引的所有叶子结点（效果约等于全表扫描）
  - `ALL`：全表扫描
- `row`：需要扫描的总行数（当然越少越好）

## 最佳实践

- 【建议】索引命名，主键索引以 `pk_` 开头；唯一索引以 `uq_` 或 `uk_` 开头；普通索引以 `idx_` 开头，一律使用小写，以字段名为后缀
- 【强制】InnoDB、MyISAM 存储引擎的索引类型必须为 `BTREE`；MEMORY 存储引擎可以是 `BTREE` 或者 `HASH`
- 【建议】单表的索引个数不超过 7 个
- 【建议】建立索引时，多考虑联合索引，区分度高的字段放前面
- 【建议】多表 `join` 的 SQL，确保被驱动表的连接列上有索引。因为这样的 `join` 效率最高（执行计划中前面的是驱动表，后面的是被驱动表）
- 【建议】加索引时，确保同一个表不存在冗余索引，比如已经有联合索引 KEY(a, b)，则 KEY(a) 是冗余的
- 【建议】结合实际业务情况，尽量使用到覆盖索引，也就是要查询出来的记录列，刚好是二级索引中的索引列，这样就避免了回表
- 【建议】不要在基数少的列上加二级索引（比如性别）。因为这样查询出来的记录本身会很多，如果需要查询的字段不止二级索引列本身的话，
    需要回表的次数也会很多，性能不好
