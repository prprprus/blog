# 泛型

## 1. 泛型的作用

- 确保编译期的强类型检查（对比 Go 中的 `interface{}`、C 中的 `void*` ）
- 可以实现通用的算法，避免为了适配不同的类型，同一套算法重复写好几次

## 2. 类型擦出

泛型作用于编译期，运行期会被擦除，比如 `ArrayList<String>` 和 `ArrayList<Object>` 在运行期是同一种类型。

```
List<String> stringArrayList = new ArrayList<>();
List<Integer> integerArrayList = new ArrayList<>();

Class classStringArrayList = stringArrayList.getClass();
Class classIntegerArrayList = integerArrayList.getClass();

System.out.println(classStringArrayList);   // class java.util.ArrayList
System.out.println(classIntegerArrayList);  // class java.util.ArrayList
System.out.println(classStringArrayList.equals(classIntegerArrayList)); // true
```

## 3. 泛型类型

### 3.1 泛型类

```
public class Generic<T> {
    
    private T value;
    
    public Generic(T value) {
        this.value = value;
    }
    
    public T getValue() {
        return value;
    }
}
```

### 3.2 泛型接口

```
public interface Generic<T> {

    T getValue();
}
```

实现类不是泛型类，指定泛型接口的类型参数：

```
public class GenericImpl implements Generic<Integer> {
    
    private int value;
    
    public GenericImpl(int value) {
        this.value = value;
    }
    
    @Override
    public Integer getValue() {
        return value;
    }
}
```

实现类是个泛型类，不指定泛型接口的类型参数：

```
public class GenericImpl<T> implements Generic<T> {
    
    private T value;
    
    public GenericImpl(T value) {
        this.value = value;
    }
    
    @Override
    public T getValue() {
        return value;
    }
}
```

## 4. 泛型和继承

`Integer` 继承于 `Object`，不过 `List<Integer>` 并不是继承于 `List<Object>`。由于类型擦出， 泛型没有独有的 `Class` 类对象，所以 `List<Integer>.class`
和 `List<Object>.class` 都是 `List.class`，所以泛型类型本身无法向上转型。

```
List<Integer> l1 = new ArrayList<>();
List<Number> l2 = l1;   // Error
```

虽然泛型本身不能向上转型，但是可以通过泛型通配符实现。

```
List<? extends Integer> l1 = new ArrayList<>();
List<? extends Number> l2 = l1;
```

## 5. 泛型方法

如果一个泛型类中含有泛型方法，那么就算是同名的 T，代表的也可能是两种不同的类型。

```
public class Generic<T> {
    
    private T key;
    
    public Generic(T key) {
        this.key = key;
    }
    
    // 这里的 T 跟 Generic<T> 的 T 可以不是同一种类型
    public <T> List<T> print(T value) {
        List<T> l = new ArrayList<>();
        l.add(value);
        return l;
    }
} 
```

## 6. 泛型通配符

### 6.1 上界通配符

可以限制泛型的类型参数必须是某个类的子类。

```
public void print(List<? extends Number> list) {

}
```

### 6.2 下界通配符

可以限制泛型的类型参数必须是某个类的父类。

```
public void print(List<? super Integer> list) {

}
```

### 6.3 无界通配符

不限制泛型的类型参数。

```
public void print(List<?> list) {

}
```

## 7. 泛型的一些规则

### 7.1 语法规则

- 泛型的类型参数不能是基本类型（值类型）
- 不能用泛型的类型参数来创建对象：`T obj = new T();`
- 不能用泛型的类型参数声明静态变量：`private static T var;`
- 不能将泛型用于 `instanceof`：`l instanceof ArrayList<Integer>`
- 泛型类不能继承异常类、不能抛出泛型的异常

### 7.2 命名规则

泛型一些约定俗成的命名：

- T - Type
- E - Element
- N - Number
- K - Key
- V - Value
