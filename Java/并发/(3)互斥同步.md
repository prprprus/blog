# 互斥同步

## 1. synchronized

### 1.1 synchronized vs. ReentrantLock

- `synchronized` 由 JVM 实现，`ReentrantLock` 由 JDK 实现
- 性能大致相同
- `synchronized` 等待锁时不可中断，`ReentrantLock` 可以
- `synchronized` 不可以设置超时，`ReentrantLock` 可以
- `synchronized` 中的锁是非公平的，`ReentrantLock` 默认非公平，也可以是公平的
- 两者都可以重入

如果不需要 `ReentrantLock` 提供的功能，应该优先选择 `synchronized`。因为性能差不多；`synchronized` 由 JVM 提供，通用性更好；`synchronized` 也不用担心忘记释放锁导致死锁，因为
JVM 会确保锁释放。

### 1.2 synchronized 使用方法

#### 1.2.1 同步一个代码块

```
class SynchronizedDemo implements Runnable {

    private Queue<Integer> queue;
    
    // 锁着共享资源
    public SynchronizedDemo(Queue<Integer> queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        synchronized (queue) {
            if (queue.size() > 0)
                queue.poll();
        }
    }
}

@Test
void Case1() {
    Queue<Integer> queue = new ArrayDeque<>(4);
    queue.add(0);
    queue.add(1);

    Thread t1 = new Thread(new SynchronizedDemo(queue));
    Thread t2 = new Thread(new SynchronizedDemo(queue));
    Thread t3 = new Thread(new SynchronizedDemo(queue));
    t1.start();
    t2.start();
    t3.start();

    System.out.println(queue);  // []
}
```

#### 1.2.2 同步一个方法

```
@Override
public synchronized void run() {
    if (queue.size() > 0)
        queue.poll();
}
```

#### 1.2.3 同步一个静态方法

```
public synchronized static void fun() {
    // ...
}
```

#### 1.2.3 同步一个类

```
class SynchronizedDemo {

    public void sum() {
        // 同步类本身, 这个类的所有对象都会同步执行该方法
        synchronized (SynchronizedDemo.class) {
            for (int i = 0; i < 10; i++) {
                System.out.println(i);
            }
        }
    }
}

@Test
void Case1() {
    SynchronizedDemo sd1 = new SynchronizedDemo();
    SynchronizedDemo sd2 = new SynchronizedDemo();
    SynchronizedDemo sd3 = new SynchronizedDemo();

    // 丢线程池中并发执行, 三组任务会按照顺序输出 0-9 
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -> sd1.sum());
    executorService.execute(() -> sd2.sum());
    executorService.execute(() -> sd3.sum());
}
```

## 2. J.U.C 中的锁

J.U.C 中的锁都实现了 `Lock` 接口：

```
public interface Lock {
    void lock();
    void lockInterruptibly() throws InterruptedException;
    boolean tryLock();
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    void unlock();
    Condition newCondition();
}
```

### 2.1 ReentrantLock

和 `synchronized` 一样，提供可重入的互斥锁。

```
class ReentrantLockDemo {

    private ReentrantLock lock = new ReentrantLock();

    public void sum() {
        try {
            lock.tryLock(3000, TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        try {
            for (int i = 0; i < 10; i++) {
                System.out.print(i);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}

@Test
void Case1() {
    ReentrantLockDemo sd1 = new ReentrantLockDemo();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -> sd1.sum());
    executorService.execute(() -> sd1.sum());
    executorService.execute(() -> sd1.sum());
}
```

### 2.2 ReentrantReadWriteLock

`ReentrantReadWriteLock` 内部维护一对读写锁，允许多个线程同时读共享变量，允许一个线程同时写共享变量，并且当有写操作时，其他线程的写操作和读操作会被禁止。适用于读多写少的场景。

```
class ReentrantReadWriteLockDemo {

    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    private Queue<String> queue;

    public ReentrantReadWriteLockDemo(Queue<String> queue) {
        this.queue = queue;
    }

    public void put(String item) {
        lock.writeLock().lock();
        try {
            queue.add(item);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.writeLock().unlock();
        }
    }

    public void pop() {
        lock.readLock().lock();
        try {
            String item = queue.poll();
            System.out.println("当前头部元素: " + item);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.readLock().unlock();
        }
    }
}
```

## 3. Condition

`synchronized` 互斥锁内可以使用 `wait()/notify()/notifyAll()` 进行线程之间的协作，J.U.C 中的锁则需要 `Condition`。

```
class Consumer implements Runnable {

    private List<String> list;
    private Lock lock;
    private Condition cond;

    public Consumer(List<String> list, Lock lock, Condition cond) {
        this.list = list;
        this.lock = lock;
        this.cond = cond;
    }

    @Override
    public void run() {
        lock.lock();
        try {
            if (list.size() == 0) {
                try {
                    System.out.println("Consumer: list 为空, 等待 Producer 生产");
                    cond.await();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            if (list.size() > 0) {
                System.out.println("Consumer: list 不为空, 进行消费: " + list.get(0));
                list.clear();
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}

class Producer implements Runnable {

    private List<String> list;
    private Lock lock;
    private Condition cond;

    public Producer(List<String> list, Lock lock, Condition cond) {
        this.list = list;
        this.lock = lock;
        this.cond = cond;
    }

    @Override
    public void run() {
        lock.lock();
        try {
            if (list.size() == 0) {
                System.out.println("Producer: list 为空, 生产中...");
                list.add("香烟");
                System.out.println("Producer: 生产完毕, 通知 Consumer 消费");
                cond.signalAll();
            } else {
                System.out.println("Producer: list 不为空, 无需生产");
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}

@Test
void Case1() {
    List<String> list = new ArrayList<>();
    Lock lock = new ReentrantLock();
    Condition cond = lock.newCondition();

    Consumer consumer = new Consumer(list, lock, cond);
    new Thread(consumer).start();
    Producer producer = new Producer(list, lock, cond);
    new Thread(producer).start();
}
```
