# 线程基础

## 1. 创建线程

### 1.1 继承 Thread 类

```
class ThreadDemo extends Thread {

    @Override
    public void run() {
        System.out.println("线程名称: " + Thread.currentThread().getName());
    }
}

@Test
void Case1() {
    ThreadDemo td1 = new ThreadDemo();
    ThreadDemo td2 = new ThreadDemo();
    td1.start();
    td2.start();
}
```

### 1.2 实现 Runnable 接口

```
class RunnableDemo implements Runnable {

    @Override
    public void run() {
        System.out.println("线程名称: " + Thread.currentThread().getName());
    }
}

@Test
void Case1() {
    Thread t1 = new Thread(new RunnableDemo());
    Thread t2 = new Thread(new RunnableDemo());
    t1.start();
    t2.start();
}
```

### 1.3 实现 Callable 接口

这种方法搭配 `FutureTask` 可以获取线程的返回值。

```
class CallableDemo implements Callable<String> {

    @Override
    public String call() {
        return Thread.currentThread().getName();
    }
}

@Test
void Case1() {
    Callable<String> callable = new CallableDemo();
    FutureTask<String> futureTask = new FutureTask<>(callable);
    new Thread(futureTask).start();
    try {
        System.out.println("从线程中获取到结果: " + futureTask.get());
    } catch (ExecutionException | InterruptedException e) {
        e.printStackTrace();
    }
}
```

## 2. 线程基本用法

### 2.1 线程的方法清单

| 方法 | 描述 |
| ------- | ---- |
|run|    线程的执行体|
|start|    线程的启动方法|
|setName|    设置线程名称|
|getName|    获取线程名称|
|setPriority|    设置线程优先级，范围 [1,10]，默认为 5|
|getPriority|    获取线程优先级|
|setDaemon|    设置成守护线程|
|isDaemon|    判断是否守护线程|
|isAlive|    判断线程是否启动|
|interrupt|    中断线程|
|Thread.interrupted|    判断线程是否已经中断，该方法会清楚中断标记|
|join|    强制等待一个线程执行，其他线程必须等待该线程运行结束才能运行|
|Thread.currentThread|    返回当前正在执行的线程对象的引用|
|Thread.sleep    |    休眠当前正在执行的线程|
|Thread.yield|    暂停当前正在执行的线程，让其他线程执行|

- `Thread.yield()`：这个礼让只是对线程调度器的建议，而且只有相同优先级的线程才能执行
- `interrupt()`：一般来说，如果一个线程没有执行 `Thread.sleep()` 等会抛出 `InterruptedException` 的操作，则调用 `interrupt()`
  无法中断该线程。但是可以在该线程的执行体中通过调用 `interrupted()` 来判断线程是否被中断了，如果返回 `true`，则主动结束线程
- 守护线程的子线程也是守护线程

## 3. 线程通信

### 3.1 wait()/notify()/notifyAll()

```
class Consumer implements Runnable {

    private List<String> list;

    public Consumer(List<String> list) {
        this.list = list;
    }

    @Override
    public void run() {
        synchronized (list) {
            if (list.size() == 0) {
                try {
                    System.out.println("Consumer: list 为空, 等待 Producer 生产");
                    list.wait();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            if (list.size() > 0) {
                System.out.println("Consumer: list 不为空, 进行消费: " + list.get(0));
                list.clear();
            }
        }
    }
}

class Producer implements Runnable {

    private List<String> list;

    public Producer(List<String> list) {
        this.list = list;
    }

    @Override
    public void run() {
        synchronized (list) {
            if (list.size() == 0) {
                System.out.println("Producer: list 为空, 生产中...");
                list.add("香烟");
                System.out.println("Producer: 生产完毕, 通知 Consumer 消费");
                list.notifyAll();
            } else {
                System.out.println("Producer: list 不为空, 无需生产");
            }
        }
    }
}

@Test
void Case1() {
    List<String> list = new ArrayList<>(3);
    Thread consumer = new Thread(new Consumer(list));
    consumer.start();
    Thread producer = new Thread(new Producer(list));
    producer.start();
}
```

### 3.2 其他

- `join()`
- 管道

## 4. 线程生命周期

![](https://raw.githubusercontent.com/prprus/Blog/master/image/java-concurrent-3.png)

- NEW：代表线程还没有调用 `start()`
- RUNNABLE：代表线程已经调用了 `start()`，在 JVM 层面是已运行，在操作系统层面可能是已运行，也可能是处于 Ready 状态
- BLOCKED：代表线程被 `synchronized` 阻塞
- WAITING：代表线程无限期等待，直到被其他线程唤醒。WAITING 是主动的，BLOCKED 是被动的
- TIMED_WAITING：代表线程带超时时间的等待
- TERMINATED：代表线程终止
