# 并发简介

## 1. 并发编程中的术语

### 1.1 并发和并行

- 并发：同一时刻只能做一件事，同一段时间内可以做多件事
- 并行：同一时刻可以做多件事，同一段时间内可以做多件事

### 1.2 同步和异步

- 同步：如果遇到阻塞的情况就一直等待，直到阻塞结束，才能继续处理下一件事情
- 异步：如果遇到阻塞的情况，就先去处理别的事情，等阻塞结束后再回过头来处理

### 1.3 阻塞和非阻塞

- 阻塞：方法调用会卡住线程的执行
- 非阻塞：方法调用不会卡住线程的执行

### 1.4 进程和线程

- 进程：操作系统资源分配的最小单位
- 线程：操作系统调度的最小单位

### 1.5 竞争条件和临界区

- 竞争条件：如果多个线程需要同时访问（读、写）一个资源，而且访问顺序会影响资源状态的正确性，那么就说存在竞争条件
- 临界区：导致竞争条件发生的代码

### 1.6 管程

Java 中的管程指的是 `synchronized/wait()/notify()/notifyAll()` 等可以实现线程安全的工具。

## 2. 并发的好处

- 提升资源利用率：CPU 个数是有限的，要处理的任务数却很多，当某个任务阻塞的时候，可能切过去处理其他的任务，提高 CPU 的利用率
- 增加程序的吞吐量：由于 Java 的线程既是并行也是并发，也就是同一时刻能够处理更多的任务

## 3. 并发的问题

### 3.1 安全性问题

并发的安全性问题指的是程序的执行结果能否符合预期。

安全性问题一般包括：

- 多核 CPU 下的缓存不可见问题
  ![](https://raw.githubusercontent.com/prprus/Blog/master/image/java-concurrent-1.png)
- 线程切换导致的原子性问题
  ![](https://raw.githubusercontent.com/prprus/Blog/master/image/java-concurrent-2.png)
- 编译器优化带来的有序性问题

解决安全性问题的方法：

- 互斥同步（阻塞同步）（`synchronized/Lock` ）
- 非阻塞同步（J.U.C 包中的原子类）
- 无同步（可重入代码、线程本地存储）

### 3.2 死锁问题

死锁的一般情况是多个线程互相等待对方的锁。

避免死锁的方法：

- 尽量不嵌套加锁，实在需要嵌套加锁也尽量按照顺序加
- 获取锁时带超时时间
- 死锁检测：为线程增加随机的优先级。同时使用 `java.lang.management` 等工具检测死锁，如果检测到死锁，中断优先级低的线程

### 3.3 上下文切换问题

并发执行的程序不一定比串行执行的程序快，因为创建线程、线程上下文切换都会有时间开销。

上线文切换指的是 CPU 从一个线程切换到另一个线程时，保存当前线程的执行环境，并恢复下一个线程的执行环境的操作。

减少上下文切换的方法：

- 减少线程数量
- 使用协程代替线程
- 使用 IO 多路复用代替多线程

## 4. 并发编程的核心

- 分工：如何将任务拆解并分配给多个线程执行
- 互斥：同一个时刻只有一个线程能访问共享资源
- 同步：多个线程之间如何写作完成任务
