# 基本数据类型

## 数据类型分类

数据类型可以分为两类：

- 值类型（即基本数据类型）：`boolean/byte/char/short/int/long/float/double`
- 引用类型：除值类型之外的都是引用类型

值类型和引用类型的区别：

- 概念方面
    - 值类型的变量名指向的是具体的值
    - 引用类型的变量名指向的是内存地址
- 使用方面
    - 不可以赋 `null` 值；使用 `==` 判断是否相等
    - 可以赋 `null` 值；使用 `equal()` 判断是否相等

## 数据类型转换

数据类型转换一般用于数值类型之间。

数据类型转换方式分为两种：

- 自动转换
- 强制转换

### 自动转换的规则

#### (1) 转换前后的数据类型要兼容

由于 `boolean` 只能存放 true 或 false，和数值类型不兼容，所以不能发生自动类型转换。

#### (2) 由小数据转换为大数据

基本数据类型从小到大的顺序为：（byte、short、char）< int < long < float < double。

```
long f = 25;
int x = 12;
Object res = f + x;
System.out.println(res.getClass().getName()); // java.lang.Long
```

## 包装类

Java 为每一种值类型都提供了对应的包装类，允许将值类型转换成引用类型，而且这个转换过程是自动的。

|Primitive type|    Wrapper class|
| ------- | ---- |
|boolean|    Boolean|
|byte|    Byte|
|char|    Character|
|float|    Float|
|int|    Integer|
|long|    Long|
|short|    Short|
|double|    Double|

- 装箱：将值类型转换成包装类的过程，默认通过调用 `valueOf()` 实现
- 拆箱：将包装类转换成值类型的过程，默认通过调用 `xxxValue()` 实现

```
Long l1 = 12L;                                  // 自动装箱
Long l2 = Long.valueOf(12L);                    // 带缓存的显式装箱
Long l3 = new Long(12L);                        // 创建一个新对象的显式装箱
System.out.println(l1.getClass().getName());    // java.lang.Long
System.out.println(l2.getClass().getName());    // java.lang.Long
System.out.println(l3.getClass().getName());    // java.lang.Long

long l11 = l1;              // 自动拆箱
System.out.println(l11);    // 12
Long l22 = l2.longValue();  // 显式拆箱
System.out.println(l22);    // 12
```

### 包装类的缓存池

缓存池规则：

- boolean：true 和 false 会被缓存
- byte：所有的字节值会被缓存
- short：-128 至 127 的值会被缓存
- int：-128 至 127 的值会被缓存
- char：\u0000 至 \u007F 会被缓存

### 包装类判断相等

示例一：

```
Long l1 = 12L;
Long l2 = Long.valueOf(12L);
Long l3 = new Long(12L);
System.out.println(l1 == l2);   // true
System.out.println(l1 == l3);   // false
System.out.println(l2 == l3);   // false
```

- `l1 == l2` 为 true：`Long l1 = 12L;` 等价于 `Long l2 = Long.valueOf(12L);`
- `l1 == l3` 为 false：`Long.valueOf(12L);` 返回的是缓存池中的对象，`new Long(12L);`
  返回的是新创建的且不在缓存池的对象
- `l2 == l3`：同上

包装类之间应该要通过 `equal()` 来判断是否相等。

示例二：

```
Long l1 = 12L;
long l2 = l1.longValue();
long l3 = new Long(12L);
System.out.println(l1 == l2);   // true
System.out.println(l1 == l3);   // true
System.out.println(l2 == l3);   // true
```

基本类型和包装类的比较，包装类会先拆箱成基本类型，再通过 `==` 比较值本身。

## 数值计算

### 浮点数计算

由于浮点数的二进制表示比较容易出现无限循环的情况，造成数值失真，所以浮点数计算应该使用 `BigDecimal` 类型。 而且初始化 `BigDecimal` 的时候要用字符串。

```
import java.math.BigDecimal;

System.out.println(new BigDecimal(0.1).add(new BigDecimal(0.2)));     // 0.3000000000000000166533453693773481063544750213623046875 
System.out.println(new BigDecimal("0.1").add(new BigDecimal("0.2"))); // 0.3
```

### 浮点数四舍五入

也应该使用 `BigDecimal`。

```
BigDecimal num1 = new BigDecimal("3.356");
BigDecimal num2 = num1.setScale(2, BigDecimal.ROUND_DOWN);
System.out.println(num2); // 3.35
BigDecimal num3 = num1.setScale(2, BigDecimal.ROUND_HALF_UP);
System.out.println(num3); // 3.36
```

### 浮点数判断相等

也应该使用 `BigDecimal`。

```
System.out.println(new BigDecimal("1.0").equals(new BigDecimal("1")));        // false
System.out.println(new BigDecimal("1.0").equals(new BigDecimal("1.0")));      // true
System.out.println(new BigDecimal("1.000").equals(new BigDecimal("1.0")));    // false
System.out.println(new BigDecimal("1.000").compareTo(new BigDecimal("1.0"))); // 0
```

`BigDecimal` 的 `equals()` 比较的是值和小数点位，如果只是想比较值，可以使用 `compareTo()`。

> `stripTrailingZeros()` 可以清掉 `BigDecimal` 小数点后的 0

### 数值溢出

对于可能会造成溢出的整型，应该使用 `BigInteger` 来存放和处理。