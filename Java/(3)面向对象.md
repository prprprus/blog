# 面向对象

## 1. 封装

### 1.1 访问权限

访问权限关键字：

- 不加默认包内可见
- public：加在类上代表外部类可以使用该类创建对象；加在成员上代表外部类可以访问这些成员
- private：加在类上代表外部类不可以使用该类创建对象；加在成员上代表外部类不可以访问这些成员
- protected：加在类上没有意义；加在成员上代表包内可见、子类可以访问这些成员

## 2. 继承

### 2.1 抽象类和接口

抽象类的一些规则：

- 抽象类不能被实例化，只能被继承
- 只要有一个抽象方法，该类就要声明为抽象类

接口的一些规则：

- 接口的成员必须都是 `public`，属性的类型默认、且必须是 `public static final`
- 实现接口的非抽象类必须实现所有方法
- 接口可以有默认方法
- 接口可以有静态方法（带实现的）

抽象类和接口的区别：

- 抽象类和子类是 IS-A 关系；接口和实现类是 LIKE-A 关系
- 一个类只能继承一个抽象类，但是可以实现多个接口
- 接口的属性类型必须有限制，抽象类没有
- 接口的成员访问权限有限制，抽象类没有

### 2.2 super

访问父类的非默认构造函数：

```
super(a, b, c)
```

访问父类的方法：

```
super.func()
```

### 2.3 重写与重载

`@Override` 的作用：

- 检查子类方法的访问权限是否大于等于父类
- 检查子类方法的返回类型是否父类方法返回类型或其子类
- 检查子类方法抛出的异常是否父类方法抛出的异常或其子类

发生重载的条件：

- 同名方法之间，参数类型、个数、顺序至少一个不同

### 2.4 类的初始化顺序

静态变量、静态块的初始化优先级高于实例变量、普通块，静态变量和静态块两者之间的初始化顺序，取决于它们在代码中的顺序。

存在继承关系的情况下，初始化顺序为：

1. 父类的静态变量、静态块
2. 子类的静态变量、静态块
3. 父类的实例变量、普通块
4. 父类的构造函数
5. 子类的实例变量、普通块
6. 子类的构造函数

## 3 Object 通用方法

### 3.1 equals()

`equals()` 用来判断两个变量是否等价，等价的意思是要么引用同一个对象，要么属性都相同。

`equals()` 与 `==` 的区别：

- 对于基本类型，没有 `equals()` 方法；使用 `==` 判断两个变量的值是否相等
- 对于引用类型，使用 `equals()` 判断两个变量是否等价；使用 `==` 判断两个变量是否引用同一个对象

`equals(Object o)` 的实现步骤：

1. 如果两个变量引用同一个对象，直接返回 `true`
2. 如果两个变量的类型都不一致，直接返回 `false`
3. 将 Object 强制转换成要比较的对象类型
4. 判断两个变量的属性是否都相等，如果是返回 `true`，否则返回 `false`

### 3.2 hashCode()

由于等价的两个变量，它们的 hash 值必须相等，所以如果重写了 `equals()`，那就必须也重写 `hashCode()`，确保等价对象的 hash 相等。

### 3.3 toString()

可以通过重写 `toString()` 自定义对象的输出形式。

### 3.4 clone()

可以通过重写 `clone()` 实现对象的深拷贝，但是比较复杂且容易出错，推荐使用像 Gson 这样的对象序列化工具实现：

```
import com.google.gson.Gson;
import lombok.Data;

@Data
class Address {

    private String street;
    private String city;
    private String country;

    public Address(String street, String city, String country) {
        this.street = street;
        this.city = city;
        this.country = country;
    }
}

@Data
class User {

    private String firstName;
    private String lastName;
    private Address address;

    public User(String firstName, String lastName, Address address) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.address = address;
    }
}

@Test
void Case1() {
    Address address = new Address("Downing St 10", "London", "England");
    User user = new User("Prime", "Minister", address);

    // For shallow copy
    //User shallowUser = new User(user.getFirstName(), user.getLastName(), user.getAddress());
    //System.out.println(user);
    //System.out.println(shallowUser);
    //
    //Address userAddress = user.getAddress();
    //userAddress.setStreet("123");
    //userAddress.setCity("456");
    //userAddress.setCountry("789");
    //user.setAddress(userAddress);
    //
    //System.out.println(user);
    //System.out.println(shallowUser);

    // For deep copy
    Gson gson = new Gson();
    User deepUser = gson.fromJson(gson.toJson(user), User.class);
    Address userAddress = user.getAddress();
    userAddress.setStreet("123");
    userAddress.setCity("456");
    userAddress.setCountry("789");
    user.setAddress(userAddress);

    System.out.println(user);
    System.out.println(deepUser);
}
```

### 3.5 其他

- `getClass()`
- `wait()` 系列方法
- `notify()`
- `notifyAll()`
- `finalize()`
