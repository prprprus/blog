# 注解

## 1. 简介

### 1.1 注解的形式

标记注解：

```
@Override
public void toString() { ... }
```

包含命名属性的注解：

```
@Author(
    name = "tiger"
    data = "2021/07/07"
)
public class Foo { ... }
```

包含未命名属性的注解：

```
@SuppressWarnings("unchecked")
public void myMethod() { ... }
```

### 1.2 注解的作用和代价

使用范围：注解一般用于类、字段、方法。（JDK8 之后还扩展了一些范围）

作用：

- 编译器根据注解检查错误（一些内置注解）
- 运行期读取注解并做相应的处理，比如 Spring 中使用各种注解来避免写配置文件

代价：

- 自定义注解依赖反射，反射的代价这些注解都有
- 相比配置文件，和代码的耦合度更高

## 2. 常用内置注解

- `@Override`：用来标记该方法覆盖了父类的方法，如果试图使用它来标记一个非父类方法时，Java 编译器会发出警告
- `@Deprecated`：用来标记该类、属性、方法已经被弃用，不建议使用
- `@SuppressWarnnings`：用来标记消除编译器警告

## 3. 元注解

元注解的作用是用来创建自定义注解。

### 3.1 @Retention

`@Retention` 指定了注解的保留级别。

属性取值：

- `RetentionPolicy.SOURCE`：标记注解仅在源文件中有效，编译器会忽略
- `RetentionPolicy.CLASS`：标记注解在 class 文件中有效，JVM 会忽略
- `RetentionPolicy.RUNTIME`：标记注解在运行期有效

```
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface People {
    public String name() "tiger";
}
```

### 3.2 @Target

`@Target` 指定了注解可以应用的元素类型。

属性取值：

- `ElementType.FIELD`：注解可以用于属性
- `ElementType.METHOD`：注解可以用于方法
- `ElementType.PARAMETER`：注解可以用于方法的参数
- `ElementType.CONSTRUCTOR`：注解可以用于构造函数
- `ElementType.LOCAL_VARIABLE`：注解可以用于局部变量
- `ElementType.PACKAGE`：注解可以用于包声明
- `ElementType.ANNOTATION_TYPE`：注解可以用于注解
- `ElementType.TYPE`：注解可以用于任意类型

### 3.3 @Documented

`@Documented` 表明注解会出现在 Javadoc。

### 3.4 @Inherited

`@Inherited` 表明注解可以被继承。

### 3.5 @Repeatable

`@Repeatable` 表明注解可以在客户端被重复使用。

```
// Spring 中的 @Scheduled
public class TaskRunner {

    @Scheduled("0 0/15 * * * ?")
    @Scheduled("0 0 12 * ?")
    public void task1() {}
}
```

## 4. 自定义注解

### 4.1 注解的定义

```
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.RetentionPolicy;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
@Documented
@interface CarInfo {
    String name() default "Benz";

    String color() default "black";

    double price() default 600000d;

    String producer() default "China";
}
```

### 4.2 注解处理器

```
class CarInfoUtil {
    public static void getCarInfo(Class<?> cls) {
        // 使用反射获取所有自定义属性
        Field[] fields = cls.getDeclaredFields();

        for (Field field : fields) {
            // 如果这个属性被 CarInfo 注解标记
            if (field.isAnnotationPresent(CarInfo.class)) {
                // 使用反射获取注解信息
                CarInfo carInfo = (CarInfo) field.getAnnotation(CarInfo.class);
                String name = carInfo.name();
                String color = carInfo.color();
                double price = carInfo.price();
                String producer = carInfo.producer();

                // 输出注解信息
                System.out.println("汽车名称: " + name);
                System.out.println("汽车颜色: " + color);
                System.out.println("汽车价格: " + price);
                System.out.println("汽车生产商: " + producer);
            }
        }
    }
}
```

### 4.3 使用注解

```
public class MixTests {

    @CarInfo(name = "BMW", color = "red", price = 656565d, producer = "japan")
    private String myCar1;

    @CarInfo
    private String myCar2;

    @Test
    void Case1() {
        CarInfoUtil.getCarInfo(MixTests.class);
    }
}
```