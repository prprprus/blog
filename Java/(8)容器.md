# 容器

## 1. 基本机制

- 容器通过泛型来确保数据的类型安全
- 容器通过实现 `Iterable` 和 `Iterator` 接口来提供迭代方法
- 容器通过 `Comparable` 和 `Comparator` 定义比较规则，区别是前者只能实现一次 `Comparable` 接口，也就是只能按照一个维度比较（比如按照某一个字段）；而后者可以定义多个 `Comparator`
  ，可以按照多个维度进行比较
- fail-fast 是容器的错误检测机制，比如在迭代操作中改变元素个数（添加、删除元素）、多线程对同步容器进行增删操作等都可能会导致 fail-fast
- Java 提供了同步容器和并发容器

## 2. List

### 2.1 ArrayList

要点：

- 基于动态数组实现
- 默认大小为 10，当 size 超过 cap 时会自动扩容为原大小的 1.5 倍。初始化时尽量指定大小，减少扩容的次数，提高性能
- 擅长随机访问操作
- 属于同步容器

### 2.2 LinkedList

要点：

- 基于双向链表实现（也可以作为队列、双端队列、栈来使用）
- 理论上没有大小限制
- 擅长针对头尾元素的操作，不擅长随机访问操作
- 属于同步容器

### 2.3 常见问题

#### 2.3.1 `Arrays.asList()` 问题

- 不能直接使用 `Arrays.asList()` 来转换基本类型数组，因为传入的基本类型数组对象会被当成一个元素。解决方法之一是把基本类型转换成包装类
- `Arrays.asList()` 返回的 `List` 不支持增删操作。因为返回的 `List` 继承的是 `AbstractList`，该类没有覆写 `add()` 和 `remove()` 方法
- 对原始数组的修改会影响到我们获得的那个 `List`。因为返回的 `List` 直接使用了数组，解决方法是在外面加一层 `new`
  ```
  String[] arr = { "1", "2", "3" };
  List list = new ArrayList<>(Arrays.asList(arr));
  ```

#### 2.3.2 `List.subList()` 问题

- 不能直接使用 `List.subList()` 返回的子列表，因为它会引用原始列表，可能会导致原始列表不能被回收，有 OOM 的风险。解决方法之一是在外面加一层 `new`
  ```
  List<Integer> subList = new ArrayList<>(list.subList(1, 4));
  ```

## 3. Map

### 3.1 HashMap

要点：

- 基于 hash 表和红黑树实现，使用拉链法来解决 hash 冲突，当链表长度 >= 8 时会转换成红黑树
- 默认大小为 16，当 size 超过 threshold 时会自动扩容为原来大小的 2 倍，并重新计算 hash 值。初始化时尽量指定大小，减少扩容和重新计算 hash 值次数，提高性能。扩容相关的参数如下
    - capacity：`HashMap` 的容量，默认 16，必须是 2^n
    - size：键值对数量，即 `Map.Entry` 数量
    - loadFactor：负载因子，取值 0.75f
    - threshold：size 的临界值，当 size >= threshold 时就会发生扩容，threshold = (int)(capacity * loadFactor)
- 允许空键和空值
- 属于同步容器

### 3.2 TreeMap

要点：

- 基于红黑树实现
- 对于每个 `Map.Entry`，根据 key 的自然顺序或者提供的 `Comparator` 进行排序
- 属于同步容器

### 3.3 LinkedHashMap

要点：

- 相当于有序的（插入顺序）`HashMap`，通过维护一个双向链表来保存插入的顺序
- 属于同步容器

## 4. Set

### 4.1 HashSet

### 4.1 TreeSet

### 4.1 LinkedHashSet

## 5. Queue
