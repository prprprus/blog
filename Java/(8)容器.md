# 容器

## 1. 基本机制

- 容器通过泛型来确保数据的类型安全
- 容器通过实现 `Iterable` 和 `Iterator` 接口来提供迭代方法
- 容器通过 `Comparable` 和 `Comparator` 定义比较规则，区别是前者只能实现一次 `Comparable` 接口，也就是只能按照一个维度比较（比如按照某一个字段）；而后者可以定义多个 `Comparator`
  ，可以按照多个维度进行比较
- fail-fast 是容器的错误检测机制，比如在迭代操作中改变元素个数（添加、删除元素）、多线程对同步容器进行增删操作等都可能会导致 fail-fast
- Java 提供了同步容器和并发容器

## 2. List

### 2.1 ArrayList

要点：

- 基于动态数组实现
- 默认大小为 10，当 size 超过 cap 时会自动扩容为原大小的 1.5 倍
- 初始化时尽量指定大小，减少扩容的次数，提高性能
- 擅长随机访问操作
- 属于同步容器

### 2.2 LinkedList

要点：

- 基于双向链表实现
- 可以作为队列、双端队列、栈来使用
- 擅长针对头尾元素的操作，不擅长随机访问操作
- 属于同步容器

### 2.3 常见问题

#### 2.3.1 `Arrays.asList()` 问题

- 不能直接使用 `Arrays.asList()` 来转换基本类型数组，因为传入的基本类型数组对象会被当成一个元素。解决方法之一是把基本类型转换成包装类
- `Arrays.asList()` 返回的 `List` 不支持增删操作。因为返回的 `List` 继承的是 `AbstractList`，该类没有覆写 `add()` 和 `remove()` 方法
- 对原始数组的修改会影响到我们获得的那个 `List`。因为返回的 `List` 直接使用了数组，解决方法是在外面加一层 `new`
  ```
  String[] arr = { "1", "2", "3" };
  List list = new ArrayList<>(Arrays.asList(arr));
  ```

#### 2.3.2 `List.subList()` 问题

- 不能直接使用 `List.subList()` 返回的子列表，因为它会引用原始列表，可能会导致原始列表不能被回收，有 OOM 的风险。解决方法之一是在外面加一层 `new`
  ```
  List<Integer> subList = new ArrayList<>(list.subList(1, 4));
  ```

### 3. Map
